//-----------------------------------
// 10.22(금) from 5-2 1p
//-----------------------------------

이전 까지에서 구현한 리스트는 사용하지못함..
메모리 릭이 있음
shared_ptr은 못씀

---- 메모리 릭의 해결방법??
- atomic shared ptr
- stamped pointer -애는 같이 해볼것

-epoch( Epoch Based Reuse)
: lock-free free list를 관리하는 방법
최악의 경우 메모리 릭이 발생
-Hazard Pointer
: 리무브를 하는데 그냥 하는게 아니라
따른 스레드가 지금 쓰고있나 직접 확인하면서 리무브를하는 것
성능은 떨어지지만 epoch랑 다르게 메모리릭이 발생하지않음

안정성 hazard, 성능 epoch
epoch, hazard의 자세한 내용은 학부생 내용이 아니므로 넘김
간단하게만다룬다..

Java?
garbage collection 이 해줌..
단 가비지 컬렉션 해주는 언어는 성능이 구짐
-----------------------------------------------------------------------------
Epoch..
별도의 카운터를 추가
공유객체를 누군가가 사용할때(add, remove를 호출할 때) 해당 카운터가 증가

- 메모리 풀을 사용,, 
delete 된 객체들을 delete list를 사용해서 delete해도 crash가 나지않도록 관리한다
그대로 두면 메모리릭이 심하므로
일정 시간이 지나면 delete_list를 비움
단, 아무생각없이 지우는게 아니라 epoch counter를  비교해서 모든 쓰레드 중에서 
epoch counter보다 작은 값을 갖는 객체만 삭제하도록 한다.

치명적인 단점..?
어떤 스레드가 메소드 호출 후, 정상 동작 하지 않아 epoch counter가 증가하지않은경우
메모리 릭이 발생할 수 있음

----------------------------------------------------------
shared_ptr의 문제점 
- 느리다...
왜 느린가?
일반적인 포인터는 pred = &curr,, 단순히 int 계산과 같음, 그대로 복사해오는것
그런데 shared_ptr은 주소의 복사뿐만 아니라 reference counter까지 관리를 해줘야 함
1. ref ++(wait-free)
2. ref--(wait-free)
3. memcpy(~~~) 형식 (non-atomic)

- atomice 문제
레퍼런스 카운터는 아토믹한데(심지어 wait-free), 포인터 자체의 접근은 아토믹하지 않음
만약 1,2,3이 각각 아토믹하다고 하더라도 전체 과정이 아토믹한것은 아님

atomic_shared_ptr은 아직 표준은 아님

atomic한 명령들을 사용해서 shared_ptr을 atomic하게 사용할수도 있음
pred->next = curr->next 형식에서
atomic_excahnge(&pred->next, atomic_load(&curr->next)처럼 사용하게 됨
각각의 명령들이 글로벌하게 lock-unlock을 걸기에 성능은 더 떨어짐
경우에 맞춰서 사용하는 경우(계정 로그인,로그아웃)도 있긴하지만 shared_ptr 어지간하면 쓰지말자...

--------------------------------------------------------------------------------------
여기서부터 새 챕터(5-2. 배경이론)

?합의 객체?
... Non-blocking 알고리즘을 만들기 위해 필요한 객체
합의수
-non-blocking 알고리즘을 만드는 능력
크면 만들수있고, 작으면 만들수 없음
만능성
- 모든 알고리즘을 wait-free하게 만들수 있는가


atomic?
기본 자료형에 대해서는
atomic<~~>을 사용하여 atomic연산을 수행하고, wait-free로 수행한다.

struct{int x,y,z;} 이정도 간단한 자료형에 대해서는 atomic하게 동작함
단, wait-free라는 보장은 없음
내부적으로 mutex를 사용하여 동작하기 때문
성능이 꾸지다는것

단 복잡한 자료구조 ex) vector등에 대해서는 적용할 수 없음
만능이 아니다...


동기화?
자료구조의 동작을 atomic하게 구현하는 알고리즘
(성긴, 세밀한, 낙천적인, 게으른, 논블로킹)
동기화를 구현하기 위해서는 기본 동기화 연산들을 적절하게 사용해야 함
(load, store, atomic_thread_fence)..각각은 wait-free 연산임
lock-unlock은 blocking연산임,, 그러니 이는 제외하고 위의 3개를 잘 스까서 사용하기
------------------------------------------------------------

증명은 어떻게?
직접 비교가 어렵기에
중간다리 개념인 합의객체를 도입하여 증명하는 방법을 사용

decide라는 동기화 연산을 가지고 있는 객체를 합의객체라고 한다

decide의 동작은? type_t decide(type_t value)
n개의 쓰레드가 decide를 호출해도 
atomic하게 동작을 하고
한쓰레드가 한번이하로만 호출(증명을 위해서 이렇게 가정,)
모든 쓰레드에서 호출했을때 동일한 결과값을 도출해야함
쓰레드가 value로 전달한 인자 중에서 값을 반환
기본 동기화 연산이기에 wait-free하고 atomic하게 동작을 해야한다.

--- 모든 쓰레드가 동일한 결과를 얻을 수 있도록 하는 방법
CAS를 사용하지 않고 합의객체를 만들수있지않느냐?
load, store를 사용해서 ...

이를 위해서 합의 수라는 개념을 설명
클래스 C를 사용해서 합의객체를 구현할 때
몇개스레드에서 합의 객체를 구현할 수 있는지를 나타내는 수

가장 처음 예시는 합의 수 1, 싱글 쓰레드에서만 가능
CAS를 사용한 것은 무한대, 쓰레드 개수에 상관없이 합의 가능

return 값에 영향을 미치는 연산은 오로지 read/write(atomic_load / store)
로컬변수에 대한 연산은 반환 결과에 중요하지않음

공유메모리 접근에 대해서만 떼어내서 ( 알고리즘의 모든 실행 가능한 경로를 이진 트리로 나타냄)
이진트리로 나타내고 이를 프토로콜이라고 부른다
트리의 높이는 정해져있음
트리의 결과를 보고 알고리즘이 맞고 틀리고를 판단가능(리프 노드의 값을 보고)

~~~ 
atomic 메모리로 2개 쓰레드 합의객체를 구현할 수 없음을 증명함
합의수 1짜리로는 합의수 2짜리를 만들 수 없음...
--> atomic 메모리 연산(합의수 1)만으로는 atomic queue 못만듬(합의수 적어도2 이상)

//-----------------------------------
// 10.26(목) from 5-2 32p
//-----------------------------------

다중 대입객체는 넘 비용이 크기에 대안으로 RMW연산 사용
read / 원래있던 값을
modify / 수정
write / 한 값을 쓰는 연산
하드웨어적인 지원이 필요
getAndAdd(~~) // C++ 공식함수는 fetchAndSet(~~)

getAndSet... 한 함수가 다른 함수를 덮어쓰는 경우
getAndIncrement()... 호출 순서가 달라져도 값이 같은 경우

최근의 cpu에서는 Common2 RMW연산을 지원하지 않는 추세..
x86은 79년도에 나온 구식 형식에서 출발하였기에 해당 연산을 지원
(sum++ 연산? getAndIncrement에 해당)

50p...
atomic 메모리 read/write만을 사용해서 
모든 자료구조를 구현할수 없는 것은 아님, 가능한 자료구조들도 있긴하다는것
CAS를 쓰면??
->계속해서 배울 내용

"만능" ??
- 모든 알고리즘을 non-blocking으로 만들수있는경우

무한대 수를 합의할 수 있는 객체는?
- CAS..
- 메모리 이동(copy), 수업시간에 다루지않음, 이 방법으로 구현된 cpu가 없음
- LL-SC, 실제 사용되고 있는 연산임
-- load linked, Store Conditional
-- 해당 내용은 뒤에서 배울 것, 모바일 기기에서 사용되는 cpu에서 지원
-- arm 에서는 기계어로 구현된 CAS연산이 없고 대신 LL-SC를 사용하는 것
-- C++11에서는 CAS만을 쓰지않느냐?
-- LL-SC를 사용해서 cas를 구현할 수 있다

56P 만능의 정의
- 클래스 C 객체..?? (합의 객체)
-

조건 A가 결정적이다?
- 같은 값(파라메터)으로 함수를 수회 호출했을 때, 같은 결과를 반환

순차객체(Sequential Object)
- 병렬화 하고자 하는 객체를 감싸서 통일시킨 형태로 객체를 표현
- 구현의 편의성 향상

Log
- 결정적이다?
-- Object a가 있을 때, a는 초기상태 or 최종상태 or 중간상태를 가질것
-- a의 상태를 복사하려면?
-- 1. 모든 member값 복사
-- 2. a의 초기상태부터 현재상태까지에 이르는 함수를 순차 호출
---- 호출된 메서드의 리스트를 Log라고 표현.. 이는 2번 방식


62P
-head는 배열로 관리함
-- 배열의 크기는 쓰레드 개수만큼, 각 쓰레드에서 데이터 레이스 회피용
-- apply함수에서 적어도 매 스탭마다 하나의 쓰레드에서는 작업을 진행하니 lock-free
-- 다른 스레드가 무엇을 해주기를 기다리지않음


//-----------------------------------
// 10.27(금)
//-----------------------------------
LockFree가 아니라 WaitFree로 변경하려면?
decide부분을 기존 lockfree알고리즘에서 변경
- starvation 해소를 위해 실패횟수를 계산하여 decide에서 지더라도
- 다른 스레드가 실패가 누적된 스레드의 작업을 대신 수행
--> 정해진 시간안에 모든 스레드가 작업을 완료
- 자세한 내용은 생략하심...
- 간단하지는 않지만 궁금한 사람들은 교재 보라~~
- 자세한 증명은 대학원 과정

- 79P 이후 수업은 생략하심

6장. 병렬알고리즘 - Queue

Pool
- 풀의 길이 제한이 있는 경우가
성능이 좋은 경우가 많음.
- 구현하기에도 쉬움
- 단, 제한이 있다는점이 치명적일 수 있기에
- 무제한 큐를 사용하는 경우도 많음

- 메소드의 성질
-- 완전
-- 부분적 .. blocking
-- 동기적.. data race가 없고, locking 신경쓸 필요가 없고, 쓰레드 개수가 많은경우
 동시다발적으로 처리하기에 오히려 성능이 높아질 수 있음
-- 우리는 무제한 완전 큐를 구현하는 것을 목표로 한다.

6P, conditionVarialble을 사용하는가?
- blocking이고 운영체제 호출을 하면서 동작하기에 고성능이 아님
- 사용하지 않는다...


16P
- if문 이후에 tail = e 사이에 다른 쓰레드가 작업을 하면 문제가 생기지 않느냐?
- if문에서 cas가 성공을 했다면 오동작하지 않음
- 다만 blocking일 뿐임
- tail = e가 될 때(업데이트될때)까지, 다른 쓰레드는 if문을 성공하지 못하므로


if (nullptr != tail->next) {
	tail = tail->next;
}의 문제점?
- 다른 스레드가 실컷 작업해둔 쓰레드를 
- 다른 쓰레드가 조작하여 결과가 사라질 수 있음
- 비단 deq뿐만 아니라, enq의 상황도 고려하면 제대로 동작하지않음

22P까지의 Deq로직에서도 문제가 있음..
- 


//-----------------------------------
// 11.04(목)
//-----------------------------------
중간고사
1. 다른 쓰레드의 Stack메모리에접근할 경우 운영체제가 예외상황을 발생시킨다.(X)
2. 메모리 일관성 문제는 다른 코어에서 실행하는 쓰레드에서 관찰되는 문제이기 떄문이다.
또한 싱글 코어 내부에서는 메모리 일관성 문제를 해결하는 HW가 존재하기 때문이다.

5.C) X... 중간값 문제가 언제 발생하는가? int의 주소가 4의 배수가 아닌경우에 발생한다.
 D) X

 7? 이유는 victim이 아토믹이 아니기 때문에 메모리 접근 역전이 일어날 수 있기 때문이다.

 8
 Node* p = head->next;
 while(p->value <= pred->value){
	if(p==pred){
		return pred->next == curr;
	}
	p = p->next;
 }

 9-1)
 int t = next;
 *removed = 1 ==(next &1);
 
 b_ A pred->cas_NEXT(curr, succ, false, false);

이전의 성긴동기화 Queue, LFQueue의 성능이 좋은가?
싱글스레드보다도 빠르지않다...
자료구조 자체의 문제...
쓰레드가 늘어나면 늘어날수록 동시다발적으로 여러곳에 접근하는 것이 아니라
head, tail에만 접근하므로 bottle neck현상... 
자료구조 자체가 병렬성이 떨어진다.
그래도 convoing을 막기 위해서라도 락프리 큐를 사용하는 것이 좋다.

드물게 crash...
생각해볼수 있는 문제?
compiler
memory ordering
중간값
ABA... 

ABA 
해결책1)
HW가 32bit, 64bit 127bit cas를 지원한다...
LL, SC 기계어 명령을 써서?
- LL,SC는 값을 보지 않고 다른 쓰레드가 해당 메모리를 건드렸는지를 통해서 파악
(dirty bit를 조사하는 방식으로)
- ABA문제는 하드웨어로 구현된 CAS를 사용할 때 발생하는 문제이다.
- 단, x86 CPU는 구형 CPU이기 떄문에 LL, SC가 없음
- 최신 CPU는 ABA문제로부터 자유롭다.
- 성능은 CAS를 사용하는 경우가 더 좋다.
- LL, SC에서는 가짜 충돌이 발생할 수 있음

2) shared_ptr를 사용
- 성능에 상관없으면 쓰면 되지만,
 성능이 중요하다면 사용하면 안된다...
- Java와 같은 gargabe collection을 사용하는 언어에서는
ABA문제가 발생하지 않는다.
- 단, Java자체가 C++에 비해서 속도가 빠르지 않기에 ...
Java로 갈빠에야 차라리 C++에서 성긴동기화를 사용할정도

3) 별도의 메모리 관리기법을 사용하는 경우
hazardPointer? 학부레벨 아님
EBR - eclass에 참고코드 올려주심

Time Stamp Version??

//-----------------------------------
// 11.05(금)
//-----------------------------------